---
layout: post
title: "섹션1-1: 시간복잡도"
date: 2025-05-17 16:14:30 +0200
img:
description:
categories: algorythm1
---
 #섹션1-1: 시간복잡도

 시간복잡도가 중요한 이유: 알고리즘을 선택하는 기준
 ㄴ주어진 문제를 해결하기 위한 연산 횟수

 빅 - 오메가 : best case 
빅 - 세타 : average case
빅 - 오: worst case

for(int i=0; i<100; i++)
N=데이터수(여기선 100)

i=0일 때 > 바로 종결 연산 1회 빅 - 오메가 
i=50일 때 > 평균 연산 N/2회 빅 - 세타
i=99일 때 > 연산 N회 빅 - 오 

실제 코딩에서는? 가장 최악을 케이스(빅 - 오)를 고려하여 test set에 임해야함
>다양한 테스트 케이스를 수행해 모든 케이스를 통과해야 합격이므로 

 
가장 많은 연산 O(n!)<O(2^n)<O(n^2)<O(nlogn)<O(n)<O(logn)<O(1) 가장 적은 연산 횟수

>쓰는 알고리즘 유형에 따라 시간 복잡도가 달라진다 

예제)정렬 - 시간 복잡도는 데이터수의 영향을 받는다 

N(1<=N<=1,000,000) 제한시간 2초 > 연산 횟수 2억번 이하 

연산 횟수 = 알고리즘 시간 복잡도 x 데이터 크기
 
버블정렬=N^2 >2억번 초과 부적합
병합 정렬=NlogN < 2억번 미만 적합 

>병합 정렬 채택 



시간 복잡도 도출 기준 
1)상수는 시간 복잡도 계산에서 제외
2)가장 많이 중첩된 반복문의 수행 횟수가 시간 복잡도의 기준이 된다 

연산횟수  N회<>3N회(for문 순차 시행) 
> 시간복잡도는 상수를 무시하므로(연산 차이 얼마 안남) 둘다 시간 복잡도는 O(N)

연산횟수 N회<>N^2회(이중for문)
이중 for문 뒤에 다른 for문이 존재하더라도 시간복잡도는 N^2+N이 아닌 N^2 유지 

시간 복잡도 활용도
1)알맞은 알고리즘 선택기준
2)비효율적인 로직 찾아서 >효율적으로 바꿈
(가장 시간복잡도를 크게 잡아먹는 부분을 확인해야 한다)

 
